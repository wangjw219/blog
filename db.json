{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/crossorigin.md","hash":"36b148d17a157ac4629f94060d6b9af2d5d3dd9d","modified":1576931190789},{"_id":"source/_posts/mobile-develop.md","hash":"8f5208976ed05fee77ef6395a41f8538ffc3259e","modified":1576931190790},{"_id":"source/_posts/https.md","hash":"e5f676eaae373c6f6a2b3421eb2e0f8cfdbb9547","modified":1576931190790},{"_id":"source/_posts/pixijs-intro.md","hash":"f08ed5fa6062ae37227988d7d3b3b9d56b29cae5","modified":1576931190790},{"_id":"source/categories/index.md","hash":"e4ae760f437c87f210d5741ca3707d7fd0ced67f","modified":1576931190791},{"_id":"source/tags/index.md","hash":"31b46ff41104c6dabf3c63330764b7f23560e82c","modified":1576931190792},{"_id":"source/_posts/prelighted-request.md","hash":"864bf6c0e98f3fe385f8c091888bc339c6ba5089","modified":1576931190791},{"_id":"source/_posts/quick-sort-md.md","hash":"e5819e3a940549513dcc3dd26f32e488e3fc384a","modified":1576931190791}],"Category":[{"name":"前端","_id":"ck4fk7h5u0002749cknnddis4"},{"name":"网络","_id":"ck4fk7h62000e749con7v9dz4"},{"name":"算法与数据结构","_id":"ck4fk7h65000k749cznilv5gs"}],"Data":[],"Page":[{"title":"categories","date":"2018-07-17T02:32:24.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-07-17 10:32:24\ntype: \"categories\"\n---\n","updated":"2019-12-21T12:26:30.791Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck4fk7h60000b749cpaelg9nf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-07-17T02:30:58.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-07-17 10:30:58\ntype: \"tags\"\n---\n","updated":"2019-12-21T12:26:30.792Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck4fk7h62000d749cx57kdyrk","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"跨域","date":"2019-02-05T00:20:47.000Z","_content":"跨域是前端开发中常见的需求，本文简要介绍跨域的原因及几种常见的跨域方案。\n<!-- more -->\n### 一、同源策略\n**同源**指的是两个页面有相同的协议头、端口号和域名，比如`http://www.baidu.com/index.html`和`htt://www.baidu.com/test.html`这两个页面就是同源的，而`http://www.baidu.com`与`https://www.baidu.com`是不同源的。\n\n**同源策略**限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。\n\n> 浏览器都有一个同源策略，其限制之一就是不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架 iframe 之间是不能进行 js 交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。\n\n**跨域请求**是指一个资源从与该资源本身所在的服务器不同的源请求一个资源时发起的HTTP请求。\n\n出于安全考虑，浏览器会限制从脚本内发起的跨域`HTTP`请求。例如，`XMLHttqRequest`和`Fetch`遵循同源策略。浏览器限制发起跨域请求或者跨域请求可以正常发起，但是返回结果被浏览器拦截了。\n\n### 二、跨域策略\n日常开发中，经常需要用到跨域实现数据共享，所以掌握跨域的技术是很重要的。\n\n#### CORS\nCORS（跨域资源共享）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。\n\n> 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。\n\n**原理**\nCORS 新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求非简单请求必须先通过 Options 方法发起预请求。\n\n新增字段：\n```\n// 请求首部字段\nOrigin: <origin>\nAccess-Control-Request-Method: <method>\nAccess-Control-Request-Headers: <field-name>[, <field-name>]*\n\n// 响应首部字段\nAccess-Control-Allow-Origin: <origin> | *\nAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header\nAccess-Control-Max-Age: <delta-seconds>\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Methods: <method>[, <method>]*\nAccess-Control-Allow-Headers: <field-name>[, <field-name>]*\n```\n**场景**\nCORS 允许在下列场景中使用跨域 HTTP 请求：\n1）由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求\n2）Web 字体 (CSS 中通过 @font-face 使用跨域字体资源）\n3）WebGL 贴图\n4）使用 canvas.drawImage 方法将 Images/video 画面绘制到 canvas\n5）样式表（使用 CSSOM）\n6）Scripts (未处理的异常)\n\n**优缺点**\n优点：CORS 支持所有类型的 HTTP 请求，且可以使用 ajax 方式获取数据。\n缺点：并不安全，但可利用 OAuth2 措施加强保障。\n\n#### **postMessage**\nwindow.postMessage() 方法可以安全地实现跨源通信。\n\n**原理**\nwindow.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（例如, 在该方法之后设置的事件、之前设置的 timeout 事件等）向目标窗口派发一个`MessageEvent` 消息。\n```\n//向其他页面发送消息\nwindow.postMessage(message, targetOrigin, [transfer]);\n\n// 其他页面监听 message 事件\nwindow.addEventListener(\"message\", (e) => {\n  let origin = event.origin || event.originalEvent.origin;\n  // 安全性验证\n  if (origin !== \"http://example.org:8080\")\n    return;\n  }\n  console.log(e);\n}, false);\n```\n**安全性问题**\n始终使用 origin 和 source 属性验证发件人的身份。\n\n#### **JSONP**\nJSONP（JSON with Padding）也是常用的一种跨域方式。\n\n**原理**\nHTML 的 script 标签可以加载并执行其他域的 JS 文件。（DOM 天生可以跨域）\n\nJSONP 实际上就是回调函数和被包含在回调函数中的 JSON。JSONP 由两部分组成：回调函数和数据。\n```\ncallback({\"name\": \"wangjw\"})\n```\n回调函数必须在浏览器执行 JSONP 响应时就要存在。\n\n一个完整的 JSONP 请求如下：\n```\n// 本地脚本文件内容\nfunction foo(response) {\n  document.getElementById(\"output\").innerHTML = response.bar;\n};\n\nvar tag = document.createElement(\"script\");\ntag.src = 'somewhere_else.php?callback=foo';\n\ndocument.getElementsByTagName(\"head\")[0].appendChild(tag);\n\n// 请求脚本文件内容\nfoo({bar: 'hello world'});\n```\n浏览器请求到脚本文件并执行的时候就调用 foo() 方法，并把 JSON 内容渲染到页面上。\n\n**场景**\n外链 JS 这种方案只支持 GET 方法，一般用于获取数据，不用来提交数据。\n\n**优缺点**\n优点：不受同源策略的限制；兼容性好。\n缺点：只能用于 GET 请求。\n\n#### **图像Ping**\n图像Ping 的跨域方式与 JSONP 一样，利用的也是 DOM 元素天生跨域的特性。\n\n**实现方式**\n```\nlet img = new Image();\n\nimg.onload = img.onerror = function() {\n  alert('done');\n}\n\nimg.src = 'http://www.exmaple.com/test?name=wangjw'\n```\n\n**应用场景**\n常用于跟踪用户点击页面（如百度统计的实现方式就是每次请求一个 gif 图片）或动态广告曝光次数。\n\n**缺点**\n只能发送 GET 请求。\n无法获取服务器的响应文本，因此只能用于浏览器与服务器间的单向通信。\n\n#### **CSST**\n一种用 CSS 跨域传输文本的方案。\n\n**原理**\n通过读取 CSS3 content 属性获取传送内容。同样利用的是 DOM 元素（link 元素）天生跨域的特性。\n\n步骤：通过 link 标签向服务器发送请求，服务器返回 CSS 文件，客户端通过获取特定元素的 content 属性来获取响应数据。\n\n**优缺点**\n优点：相比 JSONP 更为安全，不需要执行跨站脚本。\n缺点：没有 JSONP 适配广，CSST 依赖支持 CSS3 的浏览器。\n\n#### **window.name**\n在一个窗口（window）的生命周期内，窗口载入的所有的页面（iframe) 都是共享一个 window.name 的，每个页面都对 window.name 有读写权限，所以可以通过这个属性来共享数据。\n```\n// iframe a\nwindow.name.data = {\n  a: 'hello'\n}\n\n// iframe b\ndocument.getElmentById('box').innnerHTML = window.name.data.a;\n```\n#### **Hack技巧**\n1）IE6/7 下不同 iframe 共享一个 navigator 对象，可以用于传递信息。\n\n2）通过 hash 传递信息：同一个页面不同 iframe 是共享 location.hash 属性的，所以也可以通过这一属性进行通信。\n\n### **跨子域策略**\n若两个源主域相同，但子域不同，也是无法直接通信的。例如`http://h5.jd.com/a.html`和`http://m.jd.com/b.html`这两个页面就是子域不同。子域不同的两个页面，除了可以使用上面的跨域策略通信外，还有一些额外的方法可以使用。\n\n#### **document.domain**\n可以为两个子域不同的源设置相同的 document.domain 属性，这样就可以实现跨子域通信了（当然，只能把document.domain设置成自身或更高一级的父域）。比如有`http://h5.jd.com/a.html`和`http://m.jd.com/b.html`：\n```\n// iframe a\ndocument.domain = 'jd.com';\n\n// ifram b\ndocument.domain = 'jd.com';\n```\n\n**场景**\ndocument.domain 的场景只适用于不同子域的框架（iframe）间的交互，及主域必须相同的不同源。\n\n**限制**\n同域 document 提供的是页面间的互操作，需要载入 iframe 页面。\n\n**参考**\n[CSST][1]\n[HTTP访问控制][2]\n[浏览器的同源策略][3]\n\n\n  [1]: https://github.com/zswang/csst\n  [2]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\n  [3]: https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy","source":"_posts/crossorigin.md","raw":"---\ntitle: 跨域\ndate: 2019-02-05 08:20:47\ntags:\n- 网络\ncategories: [前端]\n---\n跨域是前端开发中常见的需求，本文简要介绍跨域的原因及几种常见的跨域方案。\n<!-- more -->\n### 一、同源策略\n**同源**指的是两个页面有相同的协议头、端口号和域名，比如`http://www.baidu.com/index.html`和`htt://www.baidu.com/test.html`这两个页面就是同源的，而`http://www.baidu.com`与`https://www.baidu.com`是不同源的。\n\n**同源策略**限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。\n\n> 浏览器都有一个同源策略，其限制之一就是不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架 iframe 之间是不能进行 js 交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。\n\n**跨域请求**是指一个资源从与该资源本身所在的服务器不同的源请求一个资源时发起的HTTP请求。\n\n出于安全考虑，浏览器会限制从脚本内发起的跨域`HTTP`请求。例如，`XMLHttqRequest`和`Fetch`遵循同源策略。浏览器限制发起跨域请求或者跨域请求可以正常发起，但是返回结果被浏览器拦截了。\n\n### 二、跨域策略\n日常开发中，经常需要用到跨域实现数据共享，所以掌握跨域的技术是很重要的。\n\n#### CORS\nCORS（跨域资源共享）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。\n\n> 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。\n\n**原理**\nCORS 新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求非简单请求必须先通过 Options 方法发起预请求。\n\n新增字段：\n```\n// 请求首部字段\nOrigin: <origin>\nAccess-Control-Request-Method: <method>\nAccess-Control-Request-Headers: <field-name>[, <field-name>]*\n\n// 响应首部字段\nAccess-Control-Allow-Origin: <origin> | *\nAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header\nAccess-Control-Max-Age: <delta-seconds>\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Methods: <method>[, <method>]*\nAccess-Control-Allow-Headers: <field-name>[, <field-name>]*\n```\n**场景**\nCORS 允许在下列场景中使用跨域 HTTP 请求：\n1）由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求\n2）Web 字体 (CSS 中通过 @font-face 使用跨域字体资源）\n3）WebGL 贴图\n4）使用 canvas.drawImage 方法将 Images/video 画面绘制到 canvas\n5）样式表（使用 CSSOM）\n6）Scripts (未处理的异常)\n\n**优缺点**\n优点：CORS 支持所有类型的 HTTP 请求，且可以使用 ajax 方式获取数据。\n缺点：并不安全，但可利用 OAuth2 措施加强保障。\n\n#### **postMessage**\nwindow.postMessage() 方法可以安全地实现跨源通信。\n\n**原理**\nwindow.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（例如, 在该方法之后设置的事件、之前设置的 timeout 事件等）向目标窗口派发一个`MessageEvent` 消息。\n```\n//向其他页面发送消息\nwindow.postMessage(message, targetOrigin, [transfer]);\n\n// 其他页面监听 message 事件\nwindow.addEventListener(\"message\", (e) => {\n  let origin = event.origin || event.originalEvent.origin;\n  // 安全性验证\n  if (origin !== \"http://example.org:8080\")\n    return;\n  }\n  console.log(e);\n}, false);\n```\n**安全性问题**\n始终使用 origin 和 source 属性验证发件人的身份。\n\n#### **JSONP**\nJSONP（JSON with Padding）也是常用的一种跨域方式。\n\n**原理**\nHTML 的 script 标签可以加载并执行其他域的 JS 文件。（DOM 天生可以跨域）\n\nJSONP 实际上就是回调函数和被包含在回调函数中的 JSON。JSONP 由两部分组成：回调函数和数据。\n```\ncallback({\"name\": \"wangjw\"})\n```\n回调函数必须在浏览器执行 JSONP 响应时就要存在。\n\n一个完整的 JSONP 请求如下：\n```\n// 本地脚本文件内容\nfunction foo(response) {\n  document.getElementById(\"output\").innerHTML = response.bar;\n};\n\nvar tag = document.createElement(\"script\");\ntag.src = 'somewhere_else.php?callback=foo';\n\ndocument.getElementsByTagName(\"head\")[0].appendChild(tag);\n\n// 请求脚本文件内容\nfoo({bar: 'hello world'});\n```\n浏览器请求到脚本文件并执行的时候就调用 foo() 方法，并把 JSON 内容渲染到页面上。\n\n**场景**\n外链 JS 这种方案只支持 GET 方法，一般用于获取数据，不用来提交数据。\n\n**优缺点**\n优点：不受同源策略的限制；兼容性好。\n缺点：只能用于 GET 请求。\n\n#### **图像Ping**\n图像Ping 的跨域方式与 JSONP 一样，利用的也是 DOM 元素天生跨域的特性。\n\n**实现方式**\n```\nlet img = new Image();\n\nimg.onload = img.onerror = function() {\n  alert('done');\n}\n\nimg.src = 'http://www.exmaple.com/test?name=wangjw'\n```\n\n**应用场景**\n常用于跟踪用户点击页面（如百度统计的实现方式就是每次请求一个 gif 图片）或动态广告曝光次数。\n\n**缺点**\n只能发送 GET 请求。\n无法获取服务器的响应文本，因此只能用于浏览器与服务器间的单向通信。\n\n#### **CSST**\n一种用 CSS 跨域传输文本的方案。\n\n**原理**\n通过读取 CSS3 content 属性获取传送内容。同样利用的是 DOM 元素（link 元素）天生跨域的特性。\n\n步骤：通过 link 标签向服务器发送请求，服务器返回 CSS 文件，客户端通过获取特定元素的 content 属性来获取响应数据。\n\n**优缺点**\n优点：相比 JSONP 更为安全，不需要执行跨站脚本。\n缺点：没有 JSONP 适配广，CSST 依赖支持 CSS3 的浏览器。\n\n#### **window.name**\n在一个窗口（window）的生命周期内，窗口载入的所有的页面（iframe) 都是共享一个 window.name 的，每个页面都对 window.name 有读写权限，所以可以通过这个属性来共享数据。\n```\n// iframe a\nwindow.name.data = {\n  a: 'hello'\n}\n\n// iframe b\ndocument.getElmentById('box').innnerHTML = window.name.data.a;\n```\n#### **Hack技巧**\n1）IE6/7 下不同 iframe 共享一个 navigator 对象，可以用于传递信息。\n\n2）通过 hash 传递信息：同一个页面不同 iframe 是共享 location.hash 属性的，所以也可以通过这一属性进行通信。\n\n### **跨子域策略**\n若两个源主域相同，但子域不同，也是无法直接通信的。例如`http://h5.jd.com/a.html`和`http://m.jd.com/b.html`这两个页面就是子域不同。子域不同的两个页面，除了可以使用上面的跨域策略通信外，还有一些额外的方法可以使用。\n\n#### **document.domain**\n可以为两个子域不同的源设置相同的 document.domain 属性，这样就可以实现跨子域通信了（当然，只能把document.domain设置成自身或更高一级的父域）。比如有`http://h5.jd.com/a.html`和`http://m.jd.com/b.html`：\n```\n// iframe a\ndocument.domain = 'jd.com';\n\n// ifram b\ndocument.domain = 'jd.com';\n```\n\n**场景**\ndocument.domain 的场景只适用于不同子域的框架（iframe）间的交互，及主域必须相同的不同源。\n\n**限制**\n同域 document 提供的是页面间的互操作，需要载入 iframe 页面。\n\n**参考**\n[CSST][1]\n[HTTP访问控制][2]\n[浏览器的同源策略][3]\n\n\n  [1]: https://github.com/zswang/csst\n  [2]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\n  [3]: https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy","slug":"crossorigin","published":1,"updated":"2019-12-21T12:26:30.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4fk7h5o0000749cykdfuy74","content":"<p>跨域是前端开发中常见的需求，本文简要介绍跨域的原因及几种常见的跨域方案。<br><a id=\"more\"></a></p>\n<h3 id=\"一、同源策略\"><a href=\"#一、同源策略\" class=\"headerlink\" title=\"一、同源策略\"></a>一、同源策略</h3><p><strong>同源</strong>指的是两个页面有相同的协议头、端口号和域名，比如<code>http://www.baidu.com/index.html</code>和<code>htt://www.baidu.com/test.html</code>这两个页面就是同源的，而<code>http://www.baidu.com</code>与<code>https://www.baidu.com</code>是不同源的。</p>\n<p><strong>同源策略</strong>限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</p>\n<blockquote>\n<p>浏览器都有一个同源策略，其限制之一就是不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架 iframe 之间是不能进行 js 交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。</p>\n</blockquote>\n<p><strong>跨域请求</strong>是指一个资源从与该资源本身所在的服务器不同的源请求一个资源时发起的HTTP请求。</p>\n<p>出于安全考虑，浏览器会限制从脚本内发起的跨域<code>HTTP</code>请求。例如，<code>XMLHttqRequest</code>和<code>Fetch</code>遵循同源策略。浏览器限制发起跨域请求或者跨域请求可以正常发起，但是返回结果被浏览器拦截了。</p>\n<h3 id=\"二、跨域策略\"><a href=\"#二、跨域策略\" class=\"headerlink\" title=\"二、跨域策略\"></a>二、跨域策略</h3><p>日常开发中，经常需要用到跨域实现数据共享，所以掌握跨域的技术是很重要的。</p>\n<h4 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h4><p>CORS（跨域资源共享）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<blockquote>\n<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>\n</blockquote>\n<p><strong>原理</strong><br>CORS 新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求非简单请求必须先通过 Options 方法发起预请求。</p>\n<p>新增字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 请求首部字段</span><br><span class=\"line\">Origin: &lt;origin&gt;</span><br><span class=\"line\">Access-Control-Request-Method: &lt;method&gt;</span><br><span class=\"line\">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br><span class=\"line\"></span><br><span class=\"line\">// 响应首部字段</span><br><span class=\"line\">Access-Control-Allow-Origin: &lt;origin&gt; | *</span><br><span class=\"line\">Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</span><br><span class=\"line\">Access-Control-Max-Age: &lt;delta-seconds&gt;</span><br><span class=\"line\">Access-Control-Allow-Credentials: true</span><br><span class=\"line\">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</span><br><span class=\"line\">Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></p>\n<p><strong>场景</strong><br>CORS 允许在下列场景中使用跨域 HTTP 请求：<br>1）由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求<br>2）Web 字体 (CSS 中通过 @font-face 使用跨域字体资源）<br>3）WebGL 贴图<br>4）使用 canvas.drawImage 方法将 Images/video 画面绘制到 canvas<br>5）样式表（使用 CSSOM）<br>6）Scripts (未处理的异常)</p>\n<p><strong>优缺点</strong><br>优点：CORS 支持所有类型的 HTTP 请求，且可以使用 ajax 方式获取数据。<br>缺点：并不安全，但可利用 OAuth2 措施加强保障。</p>\n<h4 id=\"postMessage\"><a href=\"#postMessage\" class=\"headerlink\" title=\"postMessage\"></a><strong>postMessage</strong></h4><p>window.postMessage() 方法可以安全地实现跨源通信。</p>\n<p><strong>原理</strong><br>window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（例如, 在该方法之后设置的事件、之前设置的 timeout 事件等）向目标窗口派发一个<code>MessageEvent</code> 消息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//向其他页面发送消息</span><br><span class=\"line\">window.postMessage(message, targetOrigin, [transfer]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 其他页面监听 message 事件</span><br><span class=\"line\">window.addEventListener(&quot;message&quot;, (e) =&gt; &#123;</span><br><span class=\"line\">  let origin = event.origin || event.originalEvent.origin;</span><br><span class=\"line\">  // 安全性验证</span><br><span class=\"line\">  if (origin !== &quot;http://example.org:8080&quot;)</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(e);</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure></p>\n<p><strong>安全性问题</strong><br>始终使用 origin 和 source 属性验证发件人的身份。</p>\n<h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a><strong>JSONP</strong></h4><p>JSONP（JSON with Padding）也是常用的一种跨域方式。</p>\n<p><strong>原理</strong><br>HTML 的 script 标签可以加载并执行其他域的 JS 文件。（DOM 天生可以跨域）</p>\n<p>JSONP 实际上就是回调函数和被包含在回调函数中的 JSON。JSONP 由两部分组成：回调函数和数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback(&#123;&quot;name&quot;: &quot;wangjw&quot;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>回调函数必须在浏览器执行 JSONP 响应时就要存在。</p>\n<p>一个完整的 JSONP 请求如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 本地脚本文件内容</span><br><span class=\"line\">function foo(response) &#123;</span><br><span class=\"line\">  document.getElementById(&quot;output&quot;).innerHTML = response.bar;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var tag = document.createElement(&quot;script&quot;);</span><br><span class=\"line\">tag.src = &apos;somewhere_else.php?callback=foo&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(tag);</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求脚本文件内容</span><br><span class=\"line\">foo(&#123;bar: &apos;hello world&apos;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>浏览器请求到脚本文件并执行的时候就调用 foo() 方法，并把 JSON 内容渲染到页面上。</p>\n<p><strong>场景</strong><br>外链 JS 这种方案只支持 GET 方法，一般用于获取数据，不用来提交数据。</p>\n<p><strong>优缺点</strong><br>优点：不受同源策略的限制；兼容性好。<br>缺点：只能用于 GET 请求。</p>\n<h4 id=\"图像Ping\"><a href=\"#图像Ping\" class=\"headerlink\" title=\"图像Ping\"></a><strong>图像Ping</strong></h4><p>图像Ping 的跨域方式与 JSONP 一样，利用的也是 DOM 元素天生跨域的特性。</p>\n<p><strong>实现方式</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let img = new Image();</span><br><span class=\"line\"></span><br><span class=\"line\">img.onload = img.onerror = function() &#123;</span><br><span class=\"line\">  alert(&apos;done&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">img.src = &apos;http://www.exmaple.com/test?name=wangjw&apos;</span><br></pre></td></tr></table></figure></p>\n<p><strong>应用场景</strong><br>常用于跟踪用户点击页面（如百度统计的实现方式就是每次请求一个 gif 图片）或动态广告曝光次数。</p>\n<p><strong>缺点</strong><br>只能发送 GET 请求。<br>无法获取服务器的响应文本，因此只能用于浏览器与服务器间的单向通信。</p>\n<h4 id=\"CSST\"><a href=\"#CSST\" class=\"headerlink\" title=\"CSST\"></a><strong>CSST</strong></h4><p>一种用 CSS 跨域传输文本的方案。</p>\n<p><strong>原理</strong><br>通过读取 CSS3 content 属性获取传送内容。同样利用的是 DOM 元素（link 元素）天生跨域的特性。</p>\n<p>步骤：通过 link 标签向服务器发送请求，服务器返回 CSS 文件，客户端通过获取特定元素的 content 属性来获取响应数据。</p>\n<p><strong>优缺点</strong><br>优点：相比 JSONP 更为安全，不需要执行跨站脚本。<br>缺点：没有 JSONP 适配广，CSST 依赖支持 CSS3 的浏览器。</p>\n<h4 id=\"window-name\"><a href=\"#window-name\" class=\"headerlink\" title=\"window.name\"></a><strong>window.name</strong></h4><p>在一个窗口（window）的生命周期内，窗口载入的所有的页面（iframe) 都是共享一个 window.name 的，每个页面都对 window.name 有读写权限，所以可以通过这个属性来共享数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iframe a</span><br><span class=\"line\">window.name.data = &#123;</span><br><span class=\"line\">  a: &apos;hello&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// iframe b</span><br><span class=\"line\">document.getElmentById(&apos;box&apos;).innnerHTML = window.name.data.a;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Hack技巧\"><a href=\"#Hack技巧\" class=\"headerlink\" title=\"Hack技巧\"></a><strong>Hack技巧</strong></h4><p>1）IE6/7 下不同 iframe 共享一个 navigator 对象，可以用于传递信息。</p>\n<p>2）通过 hash 传递信息：同一个页面不同 iframe 是共享 location.hash 属性的，所以也可以通过这一属性进行通信。</p>\n<h3 id=\"跨子域策略\"><a href=\"#跨子域策略\" class=\"headerlink\" title=\"跨子域策略\"></a><strong>跨子域策略</strong></h3><p>若两个源主域相同，但子域不同，也是无法直接通信的。例如<code>http://h5.jd.com/a.html</code>和<code>http://m.jd.com/b.html</code>这两个页面就是子域不同。子域不同的两个页面，除了可以使用上面的跨域策略通信外，还有一些额外的方法可以使用。</p>\n<h4 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a><strong>document.domain</strong></h4><p>可以为两个子域不同的源设置相同的 document.domain 属性，这样就可以实现跨子域通信了（当然，只能把document.domain设置成自身或更高一级的父域）。比如有<code>http://h5.jd.com/a.html</code>和<code>http://m.jd.com/b.html</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iframe a</span><br><span class=\"line\">document.domain = &apos;jd.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ifram b</span><br><span class=\"line\">document.domain = &apos;jd.com&apos;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>场景</strong><br>document.domain 的场景只适用于不同子域的框架（iframe）间的交互，及主域必须相同的不同源。</p>\n<p><strong>限制</strong><br>同域 document 提供的是页面间的互操作，需要载入 iframe 页面。</p>\n<p><strong>参考</strong><br><a href=\"https://github.com/zswang/csst\" target=\"_blank\" rel=\"noopener\">CSST</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\" rel=\"noopener\">HTTP访问控制</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener\">浏览器的同源策略</a></p>\n","site":{"data":{}},"excerpt":"<p>跨域是前端开发中常见的需求，本文简要介绍跨域的原因及几种常见的跨域方案。<br>","more":"</p>\n<h3 id=\"一、同源策略\"><a href=\"#一、同源策略\" class=\"headerlink\" title=\"一、同源策略\"></a>一、同源策略</h3><p><strong>同源</strong>指的是两个页面有相同的协议头、端口号和域名，比如<code>http://www.baidu.com/index.html</code>和<code>htt://www.baidu.com/test.html</code>这两个页面就是同源的，而<code>http://www.baidu.com</code>与<code>https://www.baidu.com</code>是不同源的。</p>\n<p><strong>同源策略</strong>限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</p>\n<blockquote>\n<p>浏览器都有一个同源策略，其限制之一就是不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架 iframe 之间是不能进行 js 交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。</p>\n</blockquote>\n<p><strong>跨域请求</strong>是指一个资源从与该资源本身所在的服务器不同的源请求一个资源时发起的HTTP请求。</p>\n<p>出于安全考虑，浏览器会限制从脚本内发起的跨域<code>HTTP</code>请求。例如，<code>XMLHttqRequest</code>和<code>Fetch</code>遵循同源策略。浏览器限制发起跨域请求或者跨域请求可以正常发起，但是返回结果被浏览器拦截了。</p>\n<h3 id=\"二、跨域策略\"><a href=\"#二、跨域策略\" class=\"headerlink\" title=\"二、跨域策略\"></a>二、跨域策略</h3><p>日常开发中，经常需要用到跨域实现数据共享，所以掌握跨域的技术是很重要的。</p>\n<h4 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h4><p>CORS（跨域资源共享）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<blockquote>\n<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>\n</blockquote>\n<p><strong>原理</strong><br>CORS 新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求非简单请求必须先通过 Options 方法发起预请求。</p>\n<p>新增字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 请求首部字段</span><br><span class=\"line\">Origin: &lt;origin&gt;</span><br><span class=\"line\">Access-Control-Request-Method: &lt;method&gt;</span><br><span class=\"line\">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br><span class=\"line\"></span><br><span class=\"line\">// 响应首部字段</span><br><span class=\"line\">Access-Control-Allow-Origin: &lt;origin&gt; | *</span><br><span class=\"line\">Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</span><br><span class=\"line\">Access-Control-Max-Age: &lt;delta-seconds&gt;</span><br><span class=\"line\">Access-Control-Allow-Credentials: true</span><br><span class=\"line\">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</span><br><span class=\"line\">Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></p>\n<p><strong>场景</strong><br>CORS 允许在下列场景中使用跨域 HTTP 请求：<br>1）由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求<br>2）Web 字体 (CSS 中通过 @font-face 使用跨域字体资源）<br>3）WebGL 贴图<br>4）使用 canvas.drawImage 方法将 Images/video 画面绘制到 canvas<br>5）样式表（使用 CSSOM）<br>6）Scripts (未处理的异常)</p>\n<p><strong>优缺点</strong><br>优点：CORS 支持所有类型的 HTTP 请求，且可以使用 ajax 方式获取数据。<br>缺点：并不安全，但可利用 OAuth2 措施加强保障。</p>\n<h4 id=\"postMessage\"><a href=\"#postMessage\" class=\"headerlink\" title=\"postMessage\"></a><strong>postMessage</strong></h4><p>window.postMessage() 方法可以安全地实现跨源通信。</p>\n<p><strong>原理</strong><br>window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（例如, 在该方法之后设置的事件、之前设置的 timeout 事件等）向目标窗口派发一个<code>MessageEvent</code> 消息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//向其他页面发送消息</span><br><span class=\"line\">window.postMessage(message, targetOrigin, [transfer]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 其他页面监听 message 事件</span><br><span class=\"line\">window.addEventListener(&quot;message&quot;, (e) =&gt; &#123;</span><br><span class=\"line\">  let origin = event.origin || event.originalEvent.origin;</span><br><span class=\"line\">  // 安全性验证</span><br><span class=\"line\">  if (origin !== &quot;http://example.org:8080&quot;)</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(e);</span><br><span class=\"line\">&#125;, false);</span><br></pre></td></tr></table></figure></p>\n<p><strong>安全性问题</strong><br>始终使用 origin 和 source 属性验证发件人的身份。</p>\n<h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a><strong>JSONP</strong></h4><p>JSONP（JSON with Padding）也是常用的一种跨域方式。</p>\n<p><strong>原理</strong><br>HTML 的 script 标签可以加载并执行其他域的 JS 文件。（DOM 天生可以跨域）</p>\n<p>JSONP 实际上就是回调函数和被包含在回调函数中的 JSON。JSONP 由两部分组成：回调函数和数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback(&#123;&quot;name&quot;: &quot;wangjw&quot;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>回调函数必须在浏览器执行 JSONP 响应时就要存在。</p>\n<p>一个完整的 JSONP 请求如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 本地脚本文件内容</span><br><span class=\"line\">function foo(response) &#123;</span><br><span class=\"line\">  document.getElementById(&quot;output&quot;).innerHTML = response.bar;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var tag = document.createElement(&quot;script&quot;);</span><br><span class=\"line\">tag.src = &apos;somewhere_else.php?callback=foo&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(tag);</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求脚本文件内容</span><br><span class=\"line\">foo(&#123;bar: &apos;hello world&apos;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>浏览器请求到脚本文件并执行的时候就调用 foo() 方法，并把 JSON 内容渲染到页面上。</p>\n<p><strong>场景</strong><br>外链 JS 这种方案只支持 GET 方法，一般用于获取数据，不用来提交数据。</p>\n<p><strong>优缺点</strong><br>优点：不受同源策略的限制；兼容性好。<br>缺点：只能用于 GET 请求。</p>\n<h4 id=\"图像Ping\"><a href=\"#图像Ping\" class=\"headerlink\" title=\"图像Ping\"></a><strong>图像Ping</strong></h4><p>图像Ping 的跨域方式与 JSONP 一样，利用的也是 DOM 元素天生跨域的特性。</p>\n<p><strong>实现方式</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let img = new Image();</span><br><span class=\"line\"></span><br><span class=\"line\">img.onload = img.onerror = function() &#123;</span><br><span class=\"line\">  alert(&apos;done&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">img.src = &apos;http://www.exmaple.com/test?name=wangjw&apos;</span><br></pre></td></tr></table></figure></p>\n<p><strong>应用场景</strong><br>常用于跟踪用户点击页面（如百度统计的实现方式就是每次请求一个 gif 图片）或动态广告曝光次数。</p>\n<p><strong>缺点</strong><br>只能发送 GET 请求。<br>无法获取服务器的响应文本，因此只能用于浏览器与服务器间的单向通信。</p>\n<h4 id=\"CSST\"><a href=\"#CSST\" class=\"headerlink\" title=\"CSST\"></a><strong>CSST</strong></h4><p>一种用 CSS 跨域传输文本的方案。</p>\n<p><strong>原理</strong><br>通过读取 CSS3 content 属性获取传送内容。同样利用的是 DOM 元素（link 元素）天生跨域的特性。</p>\n<p>步骤：通过 link 标签向服务器发送请求，服务器返回 CSS 文件，客户端通过获取特定元素的 content 属性来获取响应数据。</p>\n<p><strong>优缺点</strong><br>优点：相比 JSONP 更为安全，不需要执行跨站脚本。<br>缺点：没有 JSONP 适配广，CSST 依赖支持 CSS3 的浏览器。</p>\n<h4 id=\"window-name\"><a href=\"#window-name\" class=\"headerlink\" title=\"window.name\"></a><strong>window.name</strong></h4><p>在一个窗口（window）的生命周期内，窗口载入的所有的页面（iframe) 都是共享一个 window.name 的，每个页面都对 window.name 有读写权限，所以可以通过这个属性来共享数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iframe a</span><br><span class=\"line\">window.name.data = &#123;</span><br><span class=\"line\">  a: &apos;hello&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// iframe b</span><br><span class=\"line\">document.getElmentById(&apos;box&apos;).innnerHTML = window.name.data.a;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Hack技巧\"><a href=\"#Hack技巧\" class=\"headerlink\" title=\"Hack技巧\"></a><strong>Hack技巧</strong></h4><p>1）IE6/7 下不同 iframe 共享一个 navigator 对象，可以用于传递信息。</p>\n<p>2）通过 hash 传递信息：同一个页面不同 iframe 是共享 location.hash 属性的，所以也可以通过这一属性进行通信。</p>\n<h3 id=\"跨子域策略\"><a href=\"#跨子域策略\" class=\"headerlink\" title=\"跨子域策略\"></a><strong>跨子域策略</strong></h3><p>若两个源主域相同，但子域不同，也是无法直接通信的。例如<code>http://h5.jd.com/a.html</code>和<code>http://m.jd.com/b.html</code>这两个页面就是子域不同。子域不同的两个页面，除了可以使用上面的跨域策略通信外，还有一些额外的方法可以使用。</p>\n<h4 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a><strong>document.domain</strong></h4><p>可以为两个子域不同的源设置相同的 document.domain 属性，这样就可以实现跨子域通信了（当然，只能把document.domain设置成自身或更高一级的父域）。比如有<code>http://h5.jd.com/a.html</code>和<code>http://m.jd.com/b.html</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// iframe a</span><br><span class=\"line\">document.domain = &apos;jd.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ifram b</span><br><span class=\"line\">document.domain = &apos;jd.com&apos;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>场景</strong><br>document.domain 的场景只适用于不同子域的框架（iframe）间的交互，及主域必须相同的不同源。</p>\n<p><strong>限制</strong><br>同域 document 提供的是页面间的互操作，需要载入 iframe 页面。</p>\n<p><strong>参考</strong><br><a href=\"https://github.com/zswang/csst\" target=\"_blank\" rel=\"noopener\">CSST</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\" rel=\"noopener\">HTTP访问控制</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener\">浏览器的同源策略</a></p>"},{"title":"移动端开发总结","date":"2019-01-10T11:54:34.000Z","_content":"总结做移动端 wap 项目遇到的一些问题及解决方案。\n<!-- more -->\n### 滚动相关\n**使用原生滚动方案**\n类似 iscroll 等模拟滚动的库在移动端性能比较一般，特别是 ios 下有时卡顿很厉害，严重影响页面体验，所以尽量不要使用模拟滚动，而采用原生滚动。\n\n**隐藏原生滚动条**\n采用原生滚动时，页面如果很长，浏览器会渲染出一个很难看的滚动条，影响页面的整体感觉，可以采用以下两种办法隐藏该原生滚动条：\n\n1）使用浏览器私有属性进行隐藏\n\n```css\n::-webkit-scrollbar {\n  display: none;\n}\n```\n该方法的限制很明显，只有 webkit 内核的浏览器（比如 chrome）支持该私有属性。\n\n2）使用 hack 方法\n在滚动元素上添加内边距和负的外边距\n```css\n.box {\n  margin-right: -20px;\n  padding-right: 20px;\n}\n```\n### 输入框相关\n**软键盘遮挡输入框**\n在 ios 及部分 android 系统下，如果输入框处于靠近页面底部的位置，则当页面聚焦到输入框，弹出的软键盘会遮挡该输入框，解决办法如下：\n\n1）从设计层面上，输入框的位置尽量不要放在页面底部\n\n2）代码层面上的解决方案\n```javascript\n// 在输入框获取焦点时，开启一个定时器\n// input 是输入框元素\nlet timer = setInterval(() => {\n  input.scrollIntoView({ block: 'end', behavior: 'smooth'});\n}, 500);\n\n// 在输入框失去焦点时，移除定时器\nclearInterval(timer);\n```\n\n**自增高的输入框**\n`input`和`textarea`元素的高度都是固定的，当内容的高度超过其高度时，内容自会自动进行滚动，所以这两个元素的高度无法自动增高；而`div`等元素则会随内容自动增高，再加上`contentEditable`属性，就可以模拟出`input`元素展现的输入框。\n\n<p data-height=\"265\" data-theme-id=\"dark\" data-slug-hash=\"brQLOW\" data-default-tab=\"js,result\" data-user=\"Sakura0219\" data-embed-version=\"2\" data-pen-title=\"自增高的输入框\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/Sakura0219/pen/brQLOW/\">自增高的输入框</a> by Sakurrrrra (<a href=\"https://codepen.io/Sakura0219\">@Sakura0219</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n### 固定定位相关\n**固定定位元素错位**\n使用`position: fixed`属性的元素在移动端（特别是 ios 系统）下，容易出现以下问题：\n\n1） 滑动页面时，元素会出现抖动。\n2）软键盘弹出时，`position: fixed`属性会失效，元素会随着页面向上滚动。\n\n目前的解决办法是：采用内滚动。如果页面需要部分地方滚动，部分地方位置固定，则可以只在需要滚动的地方使用`overflow: scroll`属性使其滚动，其他部分则正常流动或者采用绝对定位。\n\n<p data-height=\"265\" data-theme-id=\"dark\" data-slug-hash=\"gxVjKB\" data-default-tab=\"css,result\" data-user=\"Sakura0219\" data-embed-version=\"2\" data-pen-title=\"内滚动\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/Sakura0219/pen/gxVjKB/\">内滚动</a> by Sakurrrrra (<a href=\"https://codepen.io/Sakura0219\">@Sakura0219</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n**滚动穿透**\n如果弹层使用`position: fixed`定位，在弹层是用手指进行滑动时，会导致弹层下的页面也跟着滚动，这就是\"滚动穿透\"。\n\n解决办法：在弹层出现时，给`body`元素添加属性，使其无法进行滚动。\n```css\n.body--fixed {\n  position: fixed;\n  overflow: hidden;\n  height: 100%;\n}\n```\n\n[1]: http://van.mama.cn/live/wap/wkt\n\n\n","source":"_posts/mobile-develop.md","raw":"---\ntitle: 移动端开发总结\ndate: 2019-01-10 19:54:34\ntags:\n- 移动端\ncategories: [前端]\n---\n总结做移动端 wap 项目遇到的一些问题及解决方案。\n<!-- more -->\n### 滚动相关\n**使用原生滚动方案**\n类似 iscroll 等模拟滚动的库在移动端性能比较一般，特别是 ios 下有时卡顿很厉害，严重影响页面体验，所以尽量不要使用模拟滚动，而采用原生滚动。\n\n**隐藏原生滚动条**\n采用原生滚动时，页面如果很长，浏览器会渲染出一个很难看的滚动条，影响页面的整体感觉，可以采用以下两种办法隐藏该原生滚动条：\n\n1）使用浏览器私有属性进行隐藏\n\n```css\n::-webkit-scrollbar {\n  display: none;\n}\n```\n该方法的限制很明显，只有 webkit 内核的浏览器（比如 chrome）支持该私有属性。\n\n2）使用 hack 方法\n在滚动元素上添加内边距和负的外边距\n```css\n.box {\n  margin-right: -20px;\n  padding-right: 20px;\n}\n```\n### 输入框相关\n**软键盘遮挡输入框**\n在 ios 及部分 android 系统下，如果输入框处于靠近页面底部的位置，则当页面聚焦到输入框，弹出的软键盘会遮挡该输入框，解决办法如下：\n\n1）从设计层面上，输入框的位置尽量不要放在页面底部\n\n2）代码层面上的解决方案\n```javascript\n// 在输入框获取焦点时，开启一个定时器\n// input 是输入框元素\nlet timer = setInterval(() => {\n  input.scrollIntoView({ block: 'end', behavior: 'smooth'});\n}, 500);\n\n// 在输入框失去焦点时，移除定时器\nclearInterval(timer);\n```\n\n**自增高的输入框**\n`input`和`textarea`元素的高度都是固定的，当内容的高度超过其高度时，内容自会自动进行滚动，所以这两个元素的高度无法自动增高；而`div`等元素则会随内容自动增高，再加上`contentEditable`属性，就可以模拟出`input`元素展现的输入框。\n\n<p data-height=\"265\" data-theme-id=\"dark\" data-slug-hash=\"brQLOW\" data-default-tab=\"js,result\" data-user=\"Sakura0219\" data-embed-version=\"2\" data-pen-title=\"自增高的输入框\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/Sakura0219/pen/brQLOW/\">自增高的输入框</a> by Sakurrrrra (<a href=\"https://codepen.io/Sakura0219\">@Sakura0219</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n### 固定定位相关\n**固定定位元素错位**\n使用`position: fixed`属性的元素在移动端（特别是 ios 系统）下，容易出现以下问题：\n\n1） 滑动页面时，元素会出现抖动。\n2）软键盘弹出时，`position: fixed`属性会失效，元素会随着页面向上滚动。\n\n目前的解决办法是：采用内滚动。如果页面需要部分地方滚动，部分地方位置固定，则可以只在需要滚动的地方使用`overflow: scroll`属性使其滚动，其他部分则正常流动或者采用绝对定位。\n\n<p data-height=\"265\" data-theme-id=\"dark\" data-slug-hash=\"gxVjKB\" data-default-tab=\"css,result\" data-user=\"Sakura0219\" data-embed-version=\"2\" data-pen-title=\"内滚动\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/Sakura0219/pen/gxVjKB/\">内滚动</a> by Sakurrrrra (<a href=\"https://codepen.io/Sakura0219\">@Sakura0219</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n**滚动穿透**\n如果弹层使用`position: fixed`定位，在弹层是用手指进行滑动时，会导致弹层下的页面也跟着滚动，这就是\"滚动穿透\"。\n\n解决办法：在弹层出现时，给`body`元素添加属性，使其无法进行滚动。\n```css\n.body--fixed {\n  position: fixed;\n  overflow: hidden;\n  height: 100%;\n}\n```\n\n[1]: http://van.mama.cn/live/wap/wkt\n\n\n","slug":"mobile-develop","published":1,"updated":"2019-12-21T12:26:30.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4fk7h5s0001749clhbjtl98","content":"<p>总结做移动端 wap 项目遇到的一些问题及解决方案。<br><a id=\"more\"></a></p>\n<h3 id=\"滚动相关\"><a href=\"#滚动相关\" class=\"headerlink\" title=\"滚动相关\"></a>滚动相关</h3><p><strong>使用原生滚动方案</strong><br>类似 iscroll 等模拟滚动的库在移动端性能比较一般，特别是 ios 下有时卡顿很厉害，严重影响页面体验，所以尽量不要使用模拟滚动，而采用原生滚动。</p>\n<p><strong>隐藏原生滚动条</strong><br>采用原生滚动时，页面如果很长，浏览器会渲染出一个很难看的滚动条，影响页面的整体感觉，可以采用以下两种办法隐藏该原生滚动条：</p>\n<p>1）使用浏览器私有属性进行隐藏</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">::-webkit-scrollbar</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法的限制很明显，只有 webkit 内核的浏览器（比如 chrome）支持该私有属性。</p>\n<p>2）使用 hack 方法<br>在滚动元素上添加内边距和负的外边距<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-right</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"输入框相关\"><a href=\"#输入框相关\" class=\"headerlink\" title=\"输入框相关\"></a>输入框相关</h3><p><strong>软键盘遮挡输入框</strong><br>在 ios 及部分 android 系统下，如果输入框处于靠近页面底部的位置，则当页面聚焦到输入框，弹出的软键盘会遮挡该输入框，解决办法如下：</p>\n<p>1）从设计层面上，输入框的位置尽量不要放在页面底部</p>\n<p>2）代码层面上的解决方案<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在输入框获取焦点时，开启一个定时器</span></span><br><span class=\"line\"><span class=\"comment\">// input 是输入框元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> timer = setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  input.scrollIntoView(&#123; <span class=\"attr\">block</span>: <span class=\"string\">'end'</span>, <span class=\"attr\">behavior</span>: <span class=\"string\">'smooth'</span>&#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在输入框失去焦点时，移除定时器</span></span><br><span class=\"line\">clearInterval(timer);</span><br></pre></td></tr></table></figure></p>\n<p><strong>自增高的输入框</strong><br><code>input</code>和<code>textarea</code>元素的高度都是固定的，当内容的高度超过其高度时，内容自会自动进行滚动，所以这两个元素的高度无法自动增高；而<code>div</code>等元素则会随内容自动增高，再加上<code>contentEditable</code>属性，就可以模拟出<code>input</code>元素展现的输入框。</p>\n<p></p><p data-height=\"265\" data-theme-id=\"dark\" data-slug-hash=\"brQLOW\" data-default-tab=\"js,result\" data-user=\"Sakura0219\" data-embed-version=\"2\" data-pen-title=\"自增高的输入框\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/Sakura0219/pen/brQLOW/\" target=\"_blank\" rel=\"noopener\">自增高的输入框</a> by Sakurrrrra (<a href=\"https://codepen.io/Sakura0219\" target=\"_blank\" rel=\"noopener\">@Sakura0219</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h3 id=\"固定定位相关\"><a href=\"#固定定位相关\" class=\"headerlink\" title=\"固定定位相关\"></a>固定定位相关</h3><p><strong>固定定位元素错位</strong><br>使用<code>position: fixed</code>属性的元素在移动端（特别是 ios 系统）下，容易出现以下问题：</p>\n<p>1） 滑动页面时，元素会出现抖动。<br>2）软键盘弹出时，<code>position: fixed</code>属性会失效，元素会随着页面向上滚动。</p>\n<p>目前的解决办法是：采用内滚动。如果页面需要部分地方滚动，部分地方位置固定，则可以只在需要滚动的地方使用<code>overflow: scroll</code>属性使其滚动，其他部分则正常流动或者采用绝对定位。</p>\n<p></p><p data-height=\"265\" data-theme-id=\"dark\" data-slug-hash=\"gxVjKB\" data-default-tab=\"css,result\" data-user=\"Sakura0219\" data-embed-version=\"2\" data-pen-title=\"内滚动\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/Sakura0219/pen/gxVjKB/\" target=\"_blank\" rel=\"noopener\">内滚动</a> by Sakurrrrra (<a href=\"https://codepen.io/Sakura0219\" target=\"_blank\" rel=\"noopener\">@Sakura0219</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<p><strong>滚动穿透</strong><br>如果弹层使用<code>position: fixed</code>定位，在弹层是用手指进行滑动时，会导致弹层下的页面也跟着滚动，这就是”滚动穿透”。</p>\n<p>解决办法：在弹层出现时，给<code>body</code>元素添加属性，使其无法进行滚动。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.body--fixed</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>总结做移动端 wap 项目遇到的一些问题及解决方案。<br>","more":"</p>\n<h3 id=\"滚动相关\"><a href=\"#滚动相关\" class=\"headerlink\" title=\"滚动相关\"></a>滚动相关</h3><p><strong>使用原生滚动方案</strong><br>类似 iscroll 等模拟滚动的库在移动端性能比较一般，特别是 ios 下有时卡顿很厉害，严重影响页面体验，所以尽量不要使用模拟滚动，而采用原生滚动。</p>\n<p><strong>隐藏原生滚动条</strong><br>采用原生滚动时，页面如果很长，浏览器会渲染出一个很难看的滚动条，影响页面的整体感觉，可以采用以下两种办法隐藏该原生滚动条：</p>\n<p>1）使用浏览器私有属性进行隐藏</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">::-webkit-scrollbar</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法的限制很明显，只有 webkit 内核的浏览器（比如 chrome）支持该私有属性。</p>\n<p>2）使用 hack 方法<br>在滚动元素上添加内边距和负的外边距<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-right</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"输入框相关\"><a href=\"#输入框相关\" class=\"headerlink\" title=\"输入框相关\"></a>输入框相关</h3><p><strong>软键盘遮挡输入框</strong><br>在 ios 及部分 android 系统下，如果输入框处于靠近页面底部的位置，则当页面聚焦到输入框，弹出的软键盘会遮挡该输入框，解决办法如下：</p>\n<p>1）从设计层面上，输入框的位置尽量不要放在页面底部</p>\n<p>2）代码层面上的解决方案<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在输入框获取焦点时，开启一个定时器</span></span><br><span class=\"line\"><span class=\"comment\">// input 是输入框元素</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> timer = setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  input.scrollIntoView(&#123; <span class=\"attr\">block</span>: <span class=\"string\">'end'</span>, <span class=\"attr\">behavior</span>: <span class=\"string\">'smooth'</span>&#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在输入框失去焦点时，移除定时器</span></span><br><span class=\"line\">clearInterval(timer);</span><br></pre></td></tr></table></figure></p>\n<p><strong>自增高的输入框</strong><br><code>input</code>和<code>textarea</code>元素的高度都是固定的，当内容的高度超过其高度时，内容自会自动进行滚动，所以这两个元素的高度无法自动增高；而<code>div</code>等元素则会随内容自动增高，再加上<code>contentEditable</code>属性，就可以模拟出<code>input</code>元素展现的输入框。</p>\n<p></p><p data-height=\"265\" data-theme-id=\"dark\" data-slug-hash=\"brQLOW\" data-default-tab=\"js,result\" data-user=\"Sakura0219\" data-embed-version=\"2\" data-pen-title=\"自增高的输入框\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/Sakura0219/pen/brQLOW/\" target=\"_blank\" rel=\"noopener\">自增高的输入框</a> by Sakurrrrra (<a href=\"https://codepen.io/Sakura0219\" target=\"_blank\" rel=\"noopener\">@Sakura0219</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h3 id=\"固定定位相关\"><a href=\"#固定定位相关\" class=\"headerlink\" title=\"固定定位相关\"></a>固定定位相关</h3><p><strong>固定定位元素错位</strong><br>使用<code>position: fixed</code>属性的元素在移动端（特别是 ios 系统）下，容易出现以下问题：</p>\n<p>1） 滑动页面时，元素会出现抖动。<br>2）软键盘弹出时，<code>position: fixed</code>属性会失效，元素会随着页面向上滚动。</p>\n<p>目前的解决办法是：采用内滚动。如果页面需要部分地方滚动，部分地方位置固定，则可以只在需要滚动的地方使用<code>overflow: scroll</code>属性使其滚动，其他部分则正常流动或者采用绝对定位。</p>\n<p></p><p data-height=\"265\" data-theme-id=\"dark\" data-slug-hash=\"gxVjKB\" data-default-tab=\"css,result\" data-user=\"Sakura0219\" data-embed-version=\"2\" data-pen-title=\"内滚动\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/Sakura0219/pen/gxVjKB/\" target=\"_blank\" rel=\"noopener\">内滚动</a> by Sakurrrrra (<a href=\"https://codepen.io/Sakura0219\" target=\"_blank\" rel=\"noopener\">@Sakura0219</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<p><strong>滚动穿透</strong><br>如果弹层使用<code>position: fixed</code>定位，在弹层是用手指进行滑动时，会导致弹层下的页面也跟着滚动，这就是”滚动穿透”。</p>\n<p>解决办法：在弹层出现时，给<code>body</code>元素添加属性，使其无法进行滚动。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.body--fixed</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"HTTPS 概述","date":"2019-07-01T16:20:15.000Z","_content":"HTTPS（HyperText Transfer Protocol Secure）即超文本传输安全协议，常被成为 HTTP over SSL，是一种安全的网络通信协议。HTTPS 经由 HTTP 协议进行通信，通过 SSL/TLS 协议来加密数据包。\n<!--more -->\n\n### 为什么需要 HTTPS 协议？\n\n因为 HTTP 通信并不安全：\n- 通信使用明文（不加密），内容可能会被窃听\n- 不验证通信方的身份，因此有可能遭遇伪装\n- 无法验证报文的完整性，所以有可能已遭篡改\n\n而 HTTPS 在 HTTP 的基础上添加了加密及认证机制，能够解决以上问题。\n\n### HTTPS 是如何进行通信的？\nHTTPS 协议中 HTTP 并不直接和 TCP 通信，而是先与 SSL/TLS 通信，数据经过 SSL/TLS 加密再发给 TCP。\n\n基本分为握手阶段（SSL/TLS 协议建立）和通信阶段（HTTP 通信）。\n握手阶段：客户端向服务端索要并验证公钥，然后双方协商生成\"会话密钥\"。\n通信阶段：双方采用\"会话密钥\"进行加密通信。\n\n**握手阶段详细步骤如下：**\n\n![](https://ws1.sinaimg.cn/large/e250b5bdgy1g4r3dw33tnj20g40erwem.jpg)\n\n第一步，客户端先向服务端发送加密通信的请求，这被叫做 ClientHello 请求，同时提供相关信息：\n- 支持的协议版本，如 TLS 1.0 版本。\n- 一个客户端生成的随机数，用于后面生成\"会话密钥\"。\n- 支持的加密方法，例如 RSA 公钥加密。\n- 支持的压缩方法。\n\n第二步，服务端收到客户端的请求后，发出回应，这被叫做 ServerHello，同时提供相关信息：\n- 确认使用的加密通信版本，如 TLS 1.0 版本；如果服务端和客户端支持的版本不一致，服务端会关闭加密通信。\n- 一个服务端生成的随机数，用于后面生成\"会话密钥\"。\n- 确认使用的加密方法，如 RSA 公钥加密。\n- 服务器证书。\n\n第三步，客户端验证服务端的证书，如果验证没问题，客户端就从服务端证书中提取服务端的公钥（公钥与证书绑定在一起），然后向服务端发送以下信息：\n- 一个客户端生成随机数，用于后面生成\"会话密钥\"。该随机数用服务端的公钥进行加密。\n- 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n- 客户端结束通知，表示客户端的握手阶段结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务端校验。\n\n第四步，服务端收到客户端通信后，再向客户端发送一下信息：\n- 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n- 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。\n\n**通信阶段：**\n握手阶段完成后，客户端与服务端进入加密通信阶段，使用的是普通的 HTTP 协议，只不过通信内容通过\"会话密钥\"进行加密。\n\n### HTTPS 如何解决 HTTP 的问题？\n**1. 如何防止内容被窃听？**\n对通信内容进行加密。使用的是对称密钥加密方法，密钥是通过握手阶段生成的三个随机数来生成的。\n\n**2. 如何验证通信双方的身份？**\n通过证书来认证。证书由客户端和服务端双方都可信赖的第三方结构颁发。\n\n**3. 如何保证证书的有效性？**\n接到证书的客户端可以使用证书认证机构的公开密钥对那张证书上的数字签名进行验证\n\n证书的数字签名是服务端向认证机构申请证书时，认证机构使用自己的私有密钥签署的。\n\n如何保证认证机构的公钥安全地发送给客户端？多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。\n\n**4. 如何验证报文的完整性？**\n应用层发送数据时，会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查出报文是否遭到篡改，从而保证报文的完整性。\n\n**参考**\n[SSL/TLS协议运行机制的概述][1]\n[图解 HTTP][2]\n[彻底搞懂HTTPS的加密机制][3]\n\n[1]: http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\n[2]: https://www.amazon.cn/dp/B00JTQK1L4/ref=sr_1_1?ie=UTF8&qid=1513082876&sr=8-1&keywords=%E5%9B%BE%E8%A7%A3http\n[3]: https://zhuanlan.zhihu.com/p/43789231","source":"_posts/https.md","raw":"---\ntitle: HTTPS 概述\ndate: 2019-07-02 00:20:15\ntags:\n- https\ncategories: [网络]\n---\nHTTPS（HyperText Transfer Protocol Secure）即超文本传输安全协议，常被成为 HTTP over SSL，是一种安全的网络通信协议。HTTPS 经由 HTTP 协议进行通信，通过 SSL/TLS 协议来加密数据包。\n<!--more -->\n\n### 为什么需要 HTTPS 协议？\n\n因为 HTTP 通信并不安全：\n- 通信使用明文（不加密），内容可能会被窃听\n- 不验证通信方的身份，因此有可能遭遇伪装\n- 无法验证报文的完整性，所以有可能已遭篡改\n\n而 HTTPS 在 HTTP 的基础上添加了加密及认证机制，能够解决以上问题。\n\n### HTTPS 是如何进行通信的？\nHTTPS 协议中 HTTP 并不直接和 TCP 通信，而是先与 SSL/TLS 通信，数据经过 SSL/TLS 加密再发给 TCP。\n\n基本分为握手阶段（SSL/TLS 协议建立）和通信阶段（HTTP 通信）。\n握手阶段：客户端向服务端索要并验证公钥，然后双方协商生成\"会话密钥\"。\n通信阶段：双方采用\"会话密钥\"进行加密通信。\n\n**握手阶段详细步骤如下：**\n\n![](https://ws1.sinaimg.cn/large/e250b5bdgy1g4r3dw33tnj20g40erwem.jpg)\n\n第一步，客户端先向服务端发送加密通信的请求，这被叫做 ClientHello 请求，同时提供相关信息：\n- 支持的协议版本，如 TLS 1.0 版本。\n- 一个客户端生成的随机数，用于后面生成\"会话密钥\"。\n- 支持的加密方法，例如 RSA 公钥加密。\n- 支持的压缩方法。\n\n第二步，服务端收到客户端的请求后，发出回应，这被叫做 ServerHello，同时提供相关信息：\n- 确认使用的加密通信版本，如 TLS 1.0 版本；如果服务端和客户端支持的版本不一致，服务端会关闭加密通信。\n- 一个服务端生成的随机数，用于后面生成\"会话密钥\"。\n- 确认使用的加密方法，如 RSA 公钥加密。\n- 服务器证书。\n\n第三步，客户端验证服务端的证书，如果验证没问题，客户端就从服务端证书中提取服务端的公钥（公钥与证书绑定在一起），然后向服务端发送以下信息：\n- 一个客户端生成随机数，用于后面生成\"会话密钥\"。该随机数用服务端的公钥进行加密。\n- 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n- 客户端结束通知，表示客户端的握手阶段结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务端校验。\n\n第四步，服务端收到客户端通信后，再向客户端发送一下信息：\n- 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n- 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。\n\n**通信阶段：**\n握手阶段完成后，客户端与服务端进入加密通信阶段，使用的是普通的 HTTP 协议，只不过通信内容通过\"会话密钥\"进行加密。\n\n### HTTPS 如何解决 HTTP 的问题？\n**1. 如何防止内容被窃听？**\n对通信内容进行加密。使用的是对称密钥加密方法，密钥是通过握手阶段生成的三个随机数来生成的。\n\n**2. 如何验证通信双方的身份？**\n通过证书来认证。证书由客户端和服务端双方都可信赖的第三方结构颁发。\n\n**3. 如何保证证书的有效性？**\n接到证书的客户端可以使用证书认证机构的公开密钥对那张证书上的数字签名进行验证\n\n证书的数字签名是服务端向认证机构申请证书时，认证机构使用自己的私有密钥签署的。\n\n如何保证认证机构的公钥安全地发送给客户端？多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。\n\n**4. 如何验证报文的完整性？**\n应用层发送数据时，会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查出报文是否遭到篡改，从而保证报文的完整性。\n\n**参考**\n[SSL/TLS协议运行机制的概述][1]\n[图解 HTTP][2]\n[彻底搞懂HTTPS的加密机制][3]\n\n[1]: http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\n[2]: https://www.amazon.cn/dp/B00JTQK1L4/ref=sr_1_1?ie=UTF8&qid=1513082876&sr=8-1&keywords=%E5%9B%BE%E8%A7%A3http\n[3]: https://zhuanlan.zhihu.com/p/43789231","slug":"https","published":1,"updated":"2019-12-21T12:26:30.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4fk7h60000a749c7nms8u64","content":"<p>HTTPS（HyperText Transfer Protocol Secure）即超文本传输安全协议，常被成为 HTTP over SSL，是一种安全的网络通信协议。HTTPS 经由 HTTP 协议进行通信，通过 SSL/TLS 协议来加密数据包。<br><a id=\"more\"></a></p>\n<h3 id=\"为什么需要-HTTPS-协议？\"><a href=\"#为什么需要-HTTPS-协议？\" class=\"headerlink\" title=\"为什么需要 HTTPS 协议？\"></a>为什么需要 HTTPS 协议？</h3><p>因为 HTTP 通信并不安全：</p>\n<ul>\n<li>通信使用明文（不加密），内容可能会被窃听</li>\n<li>不验证通信方的身份，因此有可能遭遇伪装</li>\n<li>无法验证报文的完整性，所以有可能已遭篡改</li>\n</ul>\n<p>而 HTTPS 在 HTTP 的基础上添加了加密及认证机制，能够解决以上问题。</p>\n<h3 id=\"HTTPS-是如何进行通信的？\"><a href=\"#HTTPS-是如何进行通信的？\" class=\"headerlink\" title=\"HTTPS 是如何进行通信的？\"></a>HTTPS 是如何进行通信的？</h3><p>HTTPS 协议中 HTTP 并不直接和 TCP 通信，而是先与 SSL/TLS 通信，数据经过 SSL/TLS 加密再发给 TCP。</p>\n<p>基本分为握手阶段（SSL/TLS 协议建立）和通信阶段（HTTP 通信）。<br>握手阶段：客户端向服务端索要并验证公钥，然后双方协商生成”会话密钥”。<br>通信阶段：双方采用”会话密钥”进行加密通信。</p>\n<p><strong>握手阶段详细步骤如下：</strong></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/e250b5bdgy1g4r3dw33tnj20g40erwem.jpg\" alt></p>\n<p>第一步，客户端先向服务端发送加密通信的请求，这被叫做 ClientHello 请求，同时提供相关信息：</p>\n<ul>\n<li>支持的协议版本，如 TLS 1.0 版本。</li>\n<li>一个客户端生成的随机数，用于后面生成”会话密钥”。</li>\n<li>支持的加密方法，例如 RSA 公钥加密。</li>\n<li>支持的压缩方法。</li>\n</ul>\n<p>第二步，服务端收到客户端的请求后，发出回应，这被叫做 ServerHello，同时提供相关信息：</p>\n<ul>\n<li>确认使用的加密通信版本，如 TLS 1.0 版本；如果服务端和客户端支持的版本不一致，服务端会关闭加密通信。</li>\n<li>一个服务端生成的随机数，用于后面生成”会话密钥”。</li>\n<li>确认使用的加密方法，如 RSA 公钥加密。</li>\n<li>服务器证书。</li>\n</ul>\n<p>第三步，客户端验证服务端的证书，如果验证没问题，客户端就从服务端证书中提取服务端的公钥（公钥与证书绑定在一起），然后向服务端发送以下信息：</p>\n<ul>\n<li>一个客户端生成随机数，用于后面生成”会话密钥”。该随机数用服务端的公钥进行加密。</li>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>\n<li>客户端结束通知，表示客户端的握手阶段结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务端校验。</li>\n</ul>\n<p>第四步，服务端收到客户端通信后，再向客户端发送一下信息：</p>\n<ul>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。</li>\n</ul>\n<p><strong>通信阶段：</strong><br>握手阶段完成后，客户端与服务端进入加密通信阶段，使用的是普通的 HTTP 协议，只不过通信内容通过”会话密钥”进行加密。</p>\n<h3 id=\"HTTPS-如何解决-HTTP-的问题？\"><a href=\"#HTTPS-如何解决-HTTP-的问题？\" class=\"headerlink\" title=\"HTTPS 如何解决 HTTP 的问题？\"></a>HTTPS 如何解决 HTTP 的问题？</h3><p><strong>1. 如何防止内容被窃听？</strong><br>对通信内容进行加密。使用的是对称密钥加密方法，密钥是通过握手阶段生成的三个随机数来生成的。</p>\n<p><strong>2. 如何验证通信双方的身份？</strong><br>通过证书来认证。证书由客户端和服务端双方都可信赖的第三方结构颁发。</p>\n<p><strong>3. 如何保证证书的有效性？</strong><br>接到证书的客户端可以使用证书认证机构的公开密钥对那张证书上的数字签名进行验证</p>\n<p>证书的数字签名是服务端向认证机构申请证书时，认证机构使用自己的私有密钥签署的。</p>\n<p>如何保证认证机构的公钥安全地发送给客户端？多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>\n<p><strong>4. 如何验证报文的完整性？</strong><br>应用层发送数据时，会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查出报文是否遭到篡改，从而保证报文的完整性。</p>\n<p><strong>参考</strong><br><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"noopener\">SSL/TLS协议运行机制的概述</a><br><a href=\"https://www.amazon.cn/dp/B00JTQK1L4/ref=sr_1_1?ie=UTF8&amp;qid=1513082876&amp;sr=8-1&amp;keywords=%E5%9B%BE%E8%A7%A3http\" target=\"_blank\" rel=\"noopener\">图解 HTTP</a><br><a href=\"https://zhuanlan.zhihu.com/p/43789231\" target=\"_blank\" rel=\"noopener\">彻底搞懂HTTPS的加密机制</a></p>\n","site":{"data":{}},"excerpt":"<p>HTTPS（HyperText Transfer Protocol Secure）即超文本传输安全协议，常被成为 HTTP over SSL，是一种安全的网络通信协议。HTTPS 经由 HTTP 协议进行通信，通过 SSL/TLS 协议来加密数据包。<br>","more":"</p>\n<h3 id=\"为什么需要-HTTPS-协议？\"><a href=\"#为什么需要-HTTPS-协议？\" class=\"headerlink\" title=\"为什么需要 HTTPS 协议？\"></a>为什么需要 HTTPS 协议？</h3><p>因为 HTTP 通信并不安全：</p>\n<ul>\n<li>通信使用明文（不加密），内容可能会被窃听</li>\n<li>不验证通信方的身份，因此有可能遭遇伪装</li>\n<li>无法验证报文的完整性，所以有可能已遭篡改</li>\n</ul>\n<p>而 HTTPS 在 HTTP 的基础上添加了加密及认证机制，能够解决以上问题。</p>\n<h3 id=\"HTTPS-是如何进行通信的？\"><a href=\"#HTTPS-是如何进行通信的？\" class=\"headerlink\" title=\"HTTPS 是如何进行通信的？\"></a>HTTPS 是如何进行通信的？</h3><p>HTTPS 协议中 HTTP 并不直接和 TCP 通信，而是先与 SSL/TLS 通信，数据经过 SSL/TLS 加密再发给 TCP。</p>\n<p>基本分为握手阶段（SSL/TLS 协议建立）和通信阶段（HTTP 通信）。<br>握手阶段：客户端向服务端索要并验证公钥，然后双方协商生成”会话密钥”。<br>通信阶段：双方采用”会话密钥”进行加密通信。</p>\n<p><strong>握手阶段详细步骤如下：</strong></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/e250b5bdgy1g4r3dw33tnj20g40erwem.jpg\" alt></p>\n<p>第一步，客户端先向服务端发送加密通信的请求，这被叫做 ClientHello 请求，同时提供相关信息：</p>\n<ul>\n<li>支持的协议版本，如 TLS 1.0 版本。</li>\n<li>一个客户端生成的随机数，用于后面生成”会话密钥”。</li>\n<li>支持的加密方法，例如 RSA 公钥加密。</li>\n<li>支持的压缩方法。</li>\n</ul>\n<p>第二步，服务端收到客户端的请求后，发出回应，这被叫做 ServerHello，同时提供相关信息：</p>\n<ul>\n<li>确认使用的加密通信版本，如 TLS 1.0 版本；如果服务端和客户端支持的版本不一致，服务端会关闭加密通信。</li>\n<li>一个服务端生成的随机数，用于后面生成”会话密钥”。</li>\n<li>确认使用的加密方法，如 RSA 公钥加密。</li>\n<li>服务器证书。</li>\n</ul>\n<p>第三步，客户端验证服务端的证书，如果验证没问题，客户端就从服务端证书中提取服务端的公钥（公钥与证书绑定在一起），然后向服务端发送以下信息：</p>\n<ul>\n<li>一个客户端生成随机数，用于后面生成”会话密钥”。该随机数用服务端的公钥进行加密。</li>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>\n<li>客户端结束通知，表示客户端的握手阶段结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务端校验。</li>\n</ul>\n<p>第四步，服务端收到客户端通信后，再向客户端发送一下信息：</p>\n<ul>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。</li>\n</ul>\n<p><strong>通信阶段：</strong><br>握手阶段完成后，客户端与服务端进入加密通信阶段，使用的是普通的 HTTP 协议，只不过通信内容通过”会话密钥”进行加密。</p>\n<h3 id=\"HTTPS-如何解决-HTTP-的问题？\"><a href=\"#HTTPS-如何解决-HTTP-的问题？\" class=\"headerlink\" title=\"HTTPS 如何解决 HTTP 的问题？\"></a>HTTPS 如何解决 HTTP 的问题？</h3><p><strong>1. 如何防止内容被窃听？</strong><br>对通信内容进行加密。使用的是对称密钥加密方法，密钥是通过握手阶段生成的三个随机数来生成的。</p>\n<p><strong>2. 如何验证通信双方的身份？</strong><br>通过证书来认证。证书由客户端和服务端双方都可信赖的第三方结构颁发。</p>\n<p><strong>3. 如何保证证书的有效性？</strong><br>接到证书的客户端可以使用证书认证机构的公开密钥对那张证书上的数字签名进行验证</p>\n<p>证书的数字签名是服务端向认证机构申请证书时，认证机构使用自己的私有密钥签署的。</p>\n<p>如何保证认证机构的公钥安全地发送给客户端？多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>\n<p><strong>4. 如何验证报文的完整性？</strong><br>应用层发送数据时，会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查出报文是否遭到篡改，从而保证报文的完整性。</p>\n<p><strong>参考</strong><br><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"noopener\">SSL/TLS协议运行机制的概述</a><br><a href=\"https://www.amazon.cn/dp/B00JTQK1L4/ref=sr_1_1?ie=UTF8&amp;qid=1513082876&amp;sr=8-1&amp;keywords=%E5%9B%BE%E8%A7%A3http\" target=\"_blank\" rel=\"noopener\">图解 HTTP</a><br><a href=\"https://zhuanlan.zhihu.com/p/43789231\" target=\"_blank\" rel=\"noopener\">彻底搞懂HTTPS的加密机制</a></p>"},{"title":"PixiJS","date":"2019-04-28T13:14:29.000Z","_content":"\nPixiJS 是一个 2D 渲染引擎，用于创建丰富的交互式图形、跨平台应用程序和游戏。\n\n<!-- more -->\n#### 简介\nPixiJS 会优先采用 WebGL API 来进行渲染，当浏览器不支持 WebGL 时会使用 canvas API 来渲染。\n\nPixiJS 封装了 WebGL API，能够让我们在不了解底层 WebGL 知识的情况下享受 WebGL 带来的硬件加速渲染效果，所以 PixiJS 渲染性能是很高的。\n\n#### 使用 PixiJS 的基本步骤\n使用 PixiJS 创建动效一般来说有一下三步：\n\n1）创建应用并挂载到页面\n```\nconst app = new PIXI.Application({\n    width: window.innerWidth,\n    height: window.innerHeight\n});\n// app.view 实际上是一个 canvas 元素的引用\ndocument.body.appendChild(app.view);\n```\n2）添加素材并渲染到页面\n```\n// 加载图片素材\nconst texture = PIXI.Texture.from('img/bunny.png');\nconst sprite = new PIXI.Sprite(texture);\n// 设置图片素材的位置\nsprite.anchor.set(0.5, 0.5);\nsprite.position.set(app.screen.width * 0.5, app.screen.height * 0.5);\n// 添加到页面上\napp.stage.addChild(sprite);\n```\n3）添加动效\n```\n// app.ticker 类似于 setInterval，会定时执行\napp.ticker.add(() => {\n    sprite.rotation += 0.1;\n});\n```\n#### PixiJS 应用的结构\n\n![pixijs-application-structure][3]\n\n一个应用 (application) 下只有一个根容器（container)，根容器下面可以包含其他容器（container)、图片 (sprite) 和文本 (text) 以及其他素材。\n\n#### PixiJS 中类的继承关系\n\n![pixijs-class-inherent][4]\n\n参考\n[PixiJS doc][1]\n[PixiJS Examples][2]\n\n[1]: http://pixijs.download/release/docs/index.html\n[2]: https://pixijs.io/examples/#/demos-basic/container.js\n[3]: https://ws1.sinaimg.cn/large/e250b5bdgy1g2lkne9ovej20m80eht9g.jpg\n[4]: https://ws1.sinaimg.cn/large/e250b5bdgy1g2lkgqq9cij22ju0uqaeb.jpg","source":"_posts/pixijs-intro.md","raw":"---\ntitle: PixiJS\ndate: 2019-04-28 21:14:29\ntags:\n- 互动技术\ncategories: [前端]\n---\n\nPixiJS 是一个 2D 渲染引擎，用于创建丰富的交互式图形、跨平台应用程序和游戏。\n\n<!-- more -->\n#### 简介\nPixiJS 会优先采用 WebGL API 来进行渲染，当浏览器不支持 WebGL 时会使用 canvas API 来渲染。\n\nPixiJS 封装了 WebGL API，能够让我们在不了解底层 WebGL 知识的情况下享受 WebGL 带来的硬件加速渲染效果，所以 PixiJS 渲染性能是很高的。\n\n#### 使用 PixiJS 的基本步骤\n使用 PixiJS 创建动效一般来说有一下三步：\n\n1）创建应用并挂载到页面\n```\nconst app = new PIXI.Application({\n    width: window.innerWidth,\n    height: window.innerHeight\n});\n// app.view 实际上是一个 canvas 元素的引用\ndocument.body.appendChild(app.view);\n```\n2）添加素材并渲染到页面\n```\n// 加载图片素材\nconst texture = PIXI.Texture.from('img/bunny.png');\nconst sprite = new PIXI.Sprite(texture);\n// 设置图片素材的位置\nsprite.anchor.set(0.5, 0.5);\nsprite.position.set(app.screen.width * 0.5, app.screen.height * 0.5);\n// 添加到页面上\napp.stage.addChild(sprite);\n```\n3）添加动效\n```\n// app.ticker 类似于 setInterval，会定时执行\napp.ticker.add(() => {\n    sprite.rotation += 0.1;\n});\n```\n#### PixiJS 应用的结构\n\n![pixijs-application-structure][3]\n\n一个应用 (application) 下只有一个根容器（container)，根容器下面可以包含其他容器（container)、图片 (sprite) 和文本 (text) 以及其他素材。\n\n#### PixiJS 中类的继承关系\n\n![pixijs-class-inherent][4]\n\n参考\n[PixiJS doc][1]\n[PixiJS Examples][2]\n\n[1]: http://pixijs.download/release/docs/index.html\n[2]: https://pixijs.io/examples/#/demos-basic/container.js\n[3]: https://ws1.sinaimg.cn/large/e250b5bdgy1g2lkne9ovej20m80eht9g.jpg\n[4]: https://ws1.sinaimg.cn/large/e250b5bdgy1g2lkgqq9cij22ju0uqaeb.jpg","slug":"pixijs-intro","published":1,"updated":"2019-12-21T12:26:30.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4fk7h61000c749cp4nvvj0q","content":"<p>PixiJS 是一个 2D 渲染引擎，用于创建丰富的交互式图形、跨平台应用程序和游戏。</p>\n<a id=\"more\"></a>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>PixiJS 会优先采用 WebGL API 来进行渲染，当浏览器不支持 WebGL 时会使用 canvas API 来渲染。</p>\n<p>PixiJS 封装了 WebGL API，能够让我们在不了解底层 WebGL 知识的情况下享受 WebGL 带来的硬件加速渲染效果，所以 PixiJS 渲染性能是很高的。</p>\n<h4 id=\"使用-PixiJS-的基本步骤\"><a href=\"#使用-PixiJS-的基本步骤\" class=\"headerlink\" title=\"使用 PixiJS 的基本步骤\"></a>使用 PixiJS 的基本步骤</h4><p>使用 PixiJS 创建动效一般来说有一下三步：</p>\n<p>1）创建应用并挂载到页面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const app = new PIXI.Application(&#123;</span><br><span class=\"line\">    width: window.innerWidth,</span><br><span class=\"line\">    height: window.innerHeight</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// app.view 实际上是一个 canvas 元素的引用</span><br><span class=\"line\">document.body.appendChild(app.view);</span><br></pre></td></tr></table></figure></p>\n<p>2）添加素材并渲染到页面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 加载图片素材</span><br><span class=\"line\">const texture = PIXI.Texture.from(&apos;img/bunny.png&apos;);</span><br><span class=\"line\">const sprite = new PIXI.Sprite(texture);</span><br><span class=\"line\">// 设置图片素材的位置</span><br><span class=\"line\">sprite.anchor.set(0.5, 0.5);</span><br><span class=\"line\">sprite.position.set(app.screen.width * 0.5, app.screen.height * 0.5);</span><br><span class=\"line\">// 添加到页面上</span><br><span class=\"line\">app.stage.addChild(sprite);</span><br></pre></td></tr></table></figure></p>\n<p>3）添加动效<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// app.ticker 类似于 setInterval，会定时执行</span><br><span class=\"line\">app.ticker.add(() =&gt; &#123;</span><br><span class=\"line\">    sprite.rotation += 0.1;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"PixiJS-应用的结构\"><a href=\"#PixiJS-应用的结构\" class=\"headerlink\" title=\"PixiJS 应用的结构\"></a>PixiJS 应用的结构</h4><p><img src=\"https://ws1.sinaimg.cn/large/e250b5bdgy1g2lkne9ovej20m80eht9g.jpg\" alt=\"pixijs-application-structure\"></p>\n<p>一个应用 (application) 下只有一个根容器（container)，根容器下面可以包含其他容器（container)、图片 (sprite) 和文本 (text) 以及其他素材。</p>\n<h4 id=\"PixiJS-中类的继承关系\"><a href=\"#PixiJS-中类的继承关系\" class=\"headerlink\" title=\"PixiJS 中类的继承关系\"></a>PixiJS 中类的继承关系</h4><p><img src=\"https://ws1.sinaimg.cn/large/e250b5bdgy1g2lkgqq9cij22ju0uqaeb.jpg\" alt=\"pixijs-class-inherent\"></p>\n<p>参考<br><a href=\"http://pixijs.download/release/docs/index.html\" target=\"_blank\" rel=\"noopener\">PixiJS doc</a><br><a href=\"https://pixijs.io/examples/#/demos-basic/container.js\" target=\"_blank\" rel=\"noopener\">PixiJS Examples</a></p>\n","site":{"data":{}},"excerpt":"<p>PixiJS 是一个 2D 渲染引擎，用于创建丰富的交互式图形、跨平台应用程序和游戏。</p>","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>PixiJS 会优先采用 WebGL API 来进行渲染，当浏览器不支持 WebGL 时会使用 canvas API 来渲染。</p>\n<p>PixiJS 封装了 WebGL API，能够让我们在不了解底层 WebGL 知识的情况下享受 WebGL 带来的硬件加速渲染效果，所以 PixiJS 渲染性能是很高的。</p>\n<h4 id=\"使用-PixiJS-的基本步骤\"><a href=\"#使用-PixiJS-的基本步骤\" class=\"headerlink\" title=\"使用 PixiJS 的基本步骤\"></a>使用 PixiJS 的基本步骤</h4><p>使用 PixiJS 创建动效一般来说有一下三步：</p>\n<p>1）创建应用并挂载到页面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const app = new PIXI.Application(&#123;</span><br><span class=\"line\">    width: window.innerWidth,</span><br><span class=\"line\">    height: window.innerHeight</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// app.view 实际上是一个 canvas 元素的引用</span><br><span class=\"line\">document.body.appendChild(app.view);</span><br></pre></td></tr></table></figure></p>\n<p>2）添加素材并渲染到页面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 加载图片素材</span><br><span class=\"line\">const texture = PIXI.Texture.from(&apos;img/bunny.png&apos;);</span><br><span class=\"line\">const sprite = new PIXI.Sprite(texture);</span><br><span class=\"line\">// 设置图片素材的位置</span><br><span class=\"line\">sprite.anchor.set(0.5, 0.5);</span><br><span class=\"line\">sprite.position.set(app.screen.width * 0.5, app.screen.height * 0.5);</span><br><span class=\"line\">// 添加到页面上</span><br><span class=\"line\">app.stage.addChild(sprite);</span><br></pre></td></tr></table></figure></p>\n<p>3）添加动效<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// app.ticker 类似于 setInterval，会定时执行</span><br><span class=\"line\">app.ticker.add(() =&gt; &#123;</span><br><span class=\"line\">    sprite.rotation += 0.1;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"PixiJS-应用的结构\"><a href=\"#PixiJS-应用的结构\" class=\"headerlink\" title=\"PixiJS 应用的结构\"></a>PixiJS 应用的结构</h4><p><img src=\"https://ws1.sinaimg.cn/large/e250b5bdgy1g2lkne9ovej20m80eht9g.jpg\" alt=\"pixijs-application-structure\"></p>\n<p>一个应用 (application) 下只有一个根容器（container)，根容器下面可以包含其他容器（container)、图片 (sprite) 和文本 (text) 以及其他素材。</p>\n<h4 id=\"PixiJS-中类的继承关系\"><a href=\"#PixiJS-中类的继承关系\" class=\"headerlink\" title=\"PixiJS 中类的继承关系\"></a>PixiJS 中类的继承关系</h4><p><img src=\"https://ws1.sinaimg.cn/large/e250b5bdgy1g2lkgqq9cij22ju0uqaeb.jpg\" alt=\"pixijs-class-inherent\"></p>\n<p>参考<br><a href=\"http://pixijs.download/release/docs/index.html\" target=\"_blank\" rel=\"noopener\">PixiJS doc</a><br><a href=\"https://pixijs.io/examples/#/demos-basic/container.js\" target=\"_blank\" rel=\"noopener\">PixiJS Examples</a></p>"},{"title":"预检请求","date":"2019-06-27T13:23:58.000Z","_content":"预检请求（Preflighted Requests）是跨域资源共享机制（CORS）中一种透明服务器验证机制。\n<!--more -->\n“需预检的请求”（也可称作非简单请求）必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n跨域资源共享中什么情况下需要发送预检请求？满足以下任意条件即可：\n\n1）使用了以下任意 HTTP 方法：\n```\nPUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH\n```\n2）认为设置了对 CORS 安全的首部字段集合之外的其他首部字段，该首部字段集合如下：\n```\nAccept\nAceept-Language\nContent-Language\nContent-Type\nDPR\nDownlink\nViewport-Width\nWidth\n```\n3）Content-Type 不属于以下之一：\n```\ntext/plain\napplication/x-www-form-urlencoded\nmultipart/form-data\n```\n4）请求中的 XMLHttpRequestUpload 对象注册了任意多个事件监听器\n\n5）请求中使用了 ReadableStream 对象","source":"_posts/prelighted-request.md","raw":"---\ntitle: 预检请求\ndate: 2019-06-27 21:23:58\ntags:\n- 网络\n- HTTP\ncategories: [前端]\n---\n预检请求（Preflighted Requests）是跨域资源共享机制（CORS）中一种透明服务器验证机制。\n<!--more -->\n“需预检的请求”（也可称作非简单请求）必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n跨域资源共享中什么情况下需要发送预检请求？满足以下任意条件即可：\n\n1）使用了以下任意 HTTP 方法：\n```\nPUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH\n```\n2）认为设置了对 CORS 安全的首部字段集合之外的其他首部字段，该首部字段集合如下：\n```\nAccept\nAceept-Language\nContent-Language\nContent-Type\nDPR\nDownlink\nViewport-Width\nWidth\n```\n3）Content-Type 不属于以下之一：\n```\ntext/plain\napplication/x-www-form-urlencoded\nmultipart/form-data\n```\n4）请求中的 XMLHttpRequestUpload 对象注册了任意多个事件监听器\n\n5）请求中使用了 ReadableStream 对象","slug":"prelighted-request","published":1,"updated":"2019-12-21T12:26:30.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4fk7h63000g749c8bznnm21","content":"<p>预检请求（Preflighted Requests）是跨域资源共享机制（CORS）中一种透明服务器验证机制。<br><a id=\"more\"></a><br>“需预检的请求”（也可称作非简单请求）必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n<p>跨域资源共享中什么情况下需要发送预检请求？满足以下任意条件即可：</p>\n<p>1）使用了以下任意 HTTP 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH</span><br></pre></td></tr></table></figure></p>\n<p>2）认为设置了对 CORS 安全的首部字段集合之外的其他首部字段，该首部字段集合如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept</span><br><span class=\"line\">Aceept-Language</span><br><span class=\"line\">Content-Language</span><br><span class=\"line\">Content-Type</span><br><span class=\"line\">DPR</span><br><span class=\"line\">Downlink</span><br><span class=\"line\">Viewport-Width</span><br><span class=\"line\">Width</span><br></pre></td></tr></table></figure></p>\n<p>3）Content-Type 不属于以下之一：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text/plain</span><br><span class=\"line\">application/x-www-form-urlencoded</span><br><span class=\"line\">multipart/form-data</span><br></pre></td></tr></table></figure></p>\n<p>4）请求中的 XMLHttpRequestUpload 对象注册了任意多个事件监听器</p>\n<p>5）请求中使用了 ReadableStream 对象</p>\n","site":{"data":{}},"excerpt":"<p>预检请求（Preflighted Requests）是跨域资源共享机制（CORS）中一种透明服务器验证机制。<br>","more":"<br>“需预检的请求”（也可称作非简单请求）必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n<p>跨域资源共享中什么情况下需要发送预检请求？满足以下任意条件即可：</p>\n<p>1）使用了以下任意 HTTP 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH</span><br></pre></td></tr></table></figure></p>\n<p>2）认为设置了对 CORS 安全的首部字段集合之外的其他首部字段，该首部字段集合如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept</span><br><span class=\"line\">Aceept-Language</span><br><span class=\"line\">Content-Language</span><br><span class=\"line\">Content-Type</span><br><span class=\"line\">DPR</span><br><span class=\"line\">Downlink</span><br><span class=\"line\">Viewport-Width</span><br><span class=\"line\">Width</span><br></pre></td></tr></table></figure></p>\n<p>3）Content-Type 不属于以下之一：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text/plain</span><br><span class=\"line\">application/x-www-form-urlencoded</span><br><span class=\"line\">multipart/form-data</span><br></pre></td></tr></table></figure></p>\n<p>4）请求中的 XMLHttpRequestUpload 对象注册了任意多个事件监听器</p>\n<p>5）请求中使用了 ReadableStream 对象</p>"},{"title":"快速排序","date":"2019-02-18T12:09:49.000Z","_content":"快速排序是一种常用的排序算法，是实际排序应用中最好的选择，因为它的平均性能很好。\n<!-- more -->\n**1. 实现步骤**\n快速排序采用了分治策略。下面是对一个典型数组进行快速排序的步骤：\n\n1）分解：取数组中任意元素作为基准元素，将数组划分为两个（可能为空）子数组（分别称为左子数组和右子数组），使得左子数组中的每一个元素都小于等于基准元素，而右子数组中的每个元素都大于基准元素。\n\n2）解决：递归调用快速排序，对左子数组和右子数组进行排序。\n\n3）合并：左子数组 + 基准元素 + 右子数组 = 排序好的数组。（如果子数组都是原址排序的，则不需要合并操作）\n\n**2. JS 实现**\n```\nfunction quickSort(arr) {\n    if (arr.length < 2) return arr;\n    // 选取基准元素，这里直接拿数组的第一个元素\n    const basicElement = arr[0];\n    let leftArr = [],\n        rightArr = [];\n    // 分解\n    for (i = 1; i < arr.length; i++) {\n        let element = arr[i];\n        if (element <= basicElement) {\n            leftArr.push(element);\n        } else {\n            rightArr.push(element);\n        }\n    }\n    // 递归调用并且合并\n    return [...quickSort(leftArr), basicElement, ...quickSort(rightArr)];\n}\n```\n**3. 性能分析**\n在理想情况下，排序 n 个项目的时间复杂度为 O(n*lgn)；在最坏情况下，排序 n 个项目的时间复杂度是 O(n<sup>2</sup>)。\n\n1）最坏情况划分：当划分产生的两个子数组分别包含 n - 1 个元素和 0 个元素时，快速排序的最坏情况产生。\n\n2）最好情况划分：在可能的最平衡的划分中，每次得到的两个数组大小都不大于 n / 2。","source":"_posts/quick-sort-md.md","raw":"---\ntitle: 快速排序\ndate: 2019-02-18 20:09:49\ntags:\n- 排序算法\ncategories: [算法与数据结构]\n---\n快速排序是一种常用的排序算法，是实际排序应用中最好的选择，因为它的平均性能很好。\n<!-- more -->\n**1. 实现步骤**\n快速排序采用了分治策略。下面是对一个典型数组进行快速排序的步骤：\n\n1）分解：取数组中任意元素作为基准元素，将数组划分为两个（可能为空）子数组（分别称为左子数组和右子数组），使得左子数组中的每一个元素都小于等于基准元素，而右子数组中的每个元素都大于基准元素。\n\n2）解决：递归调用快速排序，对左子数组和右子数组进行排序。\n\n3）合并：左子数组 + 基准元素 + 右子数组 = 排序好的数组。（如果子数组都是原址排序的，则不需要合并操作）\n\n**2. JS 实现**\n```\nfunction quickSort(arr) {\n    if (arr.length < 2) return arr;\n    // 选取基准元素，这里直接拿数组的第一个元素\n    const basicElement = arr[0];\n    let leftArr = [],\n        rightArr = [];\n    // 分解\n    for (i = 1; i < arr.length; i++) {\n        let element = arr[i];\n        if (element <= basicElement) {\n            leftArr.push(element);\n        } else {\n            rightArr.push(element);\n        }\n    }\n    // 递归调用并且合并\n    return [...quickSort(leftArr), basicElement, ...quickSort(rightArr)];\n}\n```\n**3. 性能分析**\n在理想情况下，排序 n 个项目的时间复杂度为 O(n*lgn)；在最坏情况下，排序 n 个项目的时间复杂度是 O(n<sup>2</sup>)。\n\n1）最坏情况划分：当划分产生的两个子数组分别包含 n - 1 个元素和 0 个元素时，快速排序的最坏情况产生。\n\n2）最好情况划分：在可能的最平衡的划分中，每次得到的两个数组大小都不大于 n / 2。","slug":"quick-sort-md","published":1,"updated":"2019-12-21T12:26:30.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4fk7h64000h749c6td3h71m","content":"<p>快速排序是一种常用的排序算法，是实际排序应用中最好的选择，因为它的平均性能很好。<br><a id=\"more\"></a><br><strong>1. 实现步骤</strong><br>快速排序采用了分治策略。下面是对一个典型数组进行快速排序的步骤：</p>\n<p>1）分解：取数组中任意元素作为基准元素，将数组划分为两个（可能为空）子数组（分别称为左子数组和右子数组），使得左子数组中的每一个元素都小于等于基准元素，而右子数组中的每个元素都大于基准元素。</p>\n<p>2）解决：递归调用快速排序，对左子数组和右子数组进行排序。</p>\n<p>3）合并：左子数组 + 基准元素 + 右子数组 = 排序好的数组。（如果子数组都是原址排序的，则不需要合并操作）</p>\n<p><strong>2. JS 实现</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr) &#123;</span><br><span class=\"line\">    if (arr.length &lt; 2) return arr;</span><br><span class=\"line\">    // 选取基准元素，这里直接拿数组的第一个元素</span><br><span class=\"line\">    const basicElement = arr[0];</span><br><span class=\"line\">    let leftArr = [],</span><br><span class=\"line\">        rightArr = [];</span><br><span class=\"line\">    // 分解</span><br><span class=\"line\">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        let element = arr[i];</span><br><span class=\"line\">        if (element &lt;= basicElement) &#123;</span><br><span class=\"line\">            leftArr.push(element);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            rightArr.push(element);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 递归调用并且合并</span><br><span class=\"line\">    return [...quickSort(leftArr), basicElement, ...quickSort(rightArr)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3. 性能分析</strong><br>在理想情况下，排序 n 个项目的时间复杂度为 O(n*lgn)；在最坏情况下，排序 n 个项目的时间复杂度是 O(n<sup>2</sup>)。</p>\n<p>1）最坏情况划分：当划分产生的两个子数组分别包含 n - 1 个元素和 0 个元素时，快速排序的最坏情况产生。</p>\n<p>2）最好情况划分：在可能的最平衡的划分中，每次得到的两个数组大小都不大于 n / 2。</p>\n","site":{"data":{}},"excerpt":"<p>快速排序是一种常用的排序算法，是实际排序应用中最好的选择，因为它的平均性能很好。<br>","more":"<br><strong>1. 实现步骤</strong><br>快速排序采用了分治策略。下面是对一个典型数组进行快速排序的步骤：</p>\n<p>1）分解：取数组中任意元素作为基准元素，将数组划分为两个（可能为空）子数组（分别称为左子数组和右子数组），使得左子数组中的每一个元素都小于等于基准元素，而右子数组中的每个元素都大于基准元素。</p>\n<p>2）解决：递归调用快速排序，对左子数组和右子数组进行排序。</p>\n<p>3）合并：左子数组 + 基准元素 + 右子数组 = 排序好的数组。（如果子数组都是原址排序的，则不需要合并操作）</p>\n<p><strong>2. JS 实现</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr) &#123;</span><br><span class=\"line\">    if (arr.length &lt; 2) return arr;</span><br><span class=\"line\">    // 选取基准元素，这里直接拿数组的第一个元素</span><br><span class=\"line\">    const basicElement = arr[0];</span><br><span class=\"line\">    let leftArr = [],</span><br><span class=\"line\">        rightArr = [];</span><br><span class=\"line\">    // 分解</span><br><span class=\"line\">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        let element = arr[i];</span><br><span class=\"line\">        if (element &lt;= basicElement) &#123;</span><br><span class=\"line\">            leftArr.push(element);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            rightArr.push(element);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 递归调用并且合并</span><br><span class=\"line\">    return [...quickSort(leftArr), basicElement, ...quickSort(rightArr)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3. 性能分析</strong><br>在理想情况下，排序 n 个项目的时间复杂度为 O(n*lgn)；在最坏情况下，排序 n 个项目的时间复杂度是 O(n<sup>2</sup>)。</p>\n<p>1）最坏情况划分：当划分产生的两个子数组分别包含 n - 1 个元素和 0 个元素时，快速排序的最坏情况产生。</p>\n<p>2）最好情况划分：在可能的最平衡的划分中，每次得到的两个数组大小都不大于 n / 2。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck4fk7h5o0000749cykdfuy74","category_id":"ck4fk7h5u0002749cknnddis4","_id":"ck4fk7h5x0007749c8mpo9cxe"},{"post_id":"ck4fk7h5s0001749clhbjtl98","category_id":"ck4fk7h5u0002749cknnddis4","_id":"ck4fk7h5y0009749cp0avvrtn"},{"post_id":"ck4fk7h61000c749cp4nvvj0q","category_id":"ck4fk7h5u0002749cknnddis4","_id":"ck4fk7h65000i749c565qlk1b"},{"post_id":"ck4fk7h63000g749c8bznnm21","category_id":"ck4fk7h5u0002749cknnddis4","_id":"ck4fk7h65000m749c1sfzqgiw"},{"post_id":"ck4fk7h60000a749c7nms8u64","category_id":"ck4fk7h62000e749con7v9dz4","_id":"ck4fk7h66000n749cegc3mnlh"},{"post_id":"ck4fk7h64000h749c6td3h71m","category_id":"ck4fk7h65000k749cznilv5gs","_id":"ck4fk7h66000r749ct9dqy5g4"}],"PostTag":[{"post_id":"ck4fk7h5o0000749cykdfuy74","tag_id":"ck4fk7h5v0003749cp3f133fs","_id":"ck4fk7h5x0006749c26mhk3a4"},{"post_id":"ck4fk7h5s0001749clhbjtl98","tag_id":"ck4fk7h5w0005749cevkuvj26","_id":"ck4fk7h5x0008749cmbp5nhhm"},{"post_id":"ck4fk7h60000a749c7nms8u64","tag_id":"ck4fk7h62000f749cwp0id1ma","_id":"ck4fk7h65000l749c4boxzdmg"},{"post_id":"ck4fk7h61000c749cp4nvvj0q","tag_id":"ck4fk7h65000j749cqyifeqlq","_id":"ck4fk7h66000p749cn7xalr4l"},{"post_id":"ck4fk7h63000g749c8bznnm21","tag_id":"ck4fk7h5v0003749cp3f133fs","_id":"ck4fk7h66000s749cwg0fx6yi"},{"post_id":"ck4fk7h63000g749c8bznnm21","tag_id":"ck4fk7h66000o749c347dq7yg","_id":"ck4fk7h66000t749cmo6edug4"},{"post_id":"ck4fk7h64000h749c6td3h71m","tag_id":"ck4fk7h66000q749ci0e87g8y","_id":"ck4fk7h66000u749c8fwz3x8c"}],"Tag":[{"name":"网络","_id":"ck4fk7h5v0003749cp3f133fs"},{"name":"移动端","_id":"ck4fk7h5w0005749cevkuvj26"},{"name":"https","_id":"ck4fk7h62000f749cwp0id1ma"},{"name":"互动技术","_id":"ck4fk7h65000j749cqyifeqlq"},{"name":"HTTP","_id":"ck4fk7h66000o749c347dq7yg"},{"name":"排序算法","_id":"ck4fk7h66000q749ci0e87g8y"}]}}